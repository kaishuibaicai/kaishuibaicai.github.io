---
layout:     post
title:      软件测试的学习笔记
subtitle:   Software test-learning
date:       2017-08-23 18:34:00
author:     "Ksbc"
header-img: "img/20170823/test.jpg"
tags:
    - 测试
---

>  软件测试的学习笔记

### 《软件测试的艺术》

**所谓软件测试**，就是一个过程或一系列过程，用来确认计算机代码完成了其应该完成的功能，不执行其不该有的操作。软件应该是可预测且稳定的，不会给用户带来意外的惊奇。测试程序不是为了证明软件问题，而是为了找出软件的问题。**测试是为了发现错误而执行程序的过程。**本着证明程序存在错误，比证明程序没有错误更能发现问题。将软件测试定义为发现程序错误的过程，使得测试是个可以完成的任务。并且，**软件测试是不可能发现程序‘所有’的错误。**



#### 黑盒测试

是一种以数据驱动的测试或输入\输出驱动的测试。将程序视为一个黑盒子，测试目标与程序的内部机制和结构完全无关，而将重点集中放在程序不按其规范正确运行的环境条件。因此测试数据完全源于**软件规范**，这样就需要进行**穷举输入测试**，将所有可能的输入条件作为测试用例。

**但是**，穷举输入测试是无法实现的，测试人的目标在于通过有限的测试用例，最大限度地提高发现问题的数量，已取得最好的测试效果。因此，除了其他因素之外，要实现这个目标，还需要能够窥见软件的内部，对程序作合理但非无懈可击的假设。

- 等价类划分
- 边界值分析
- 因果图分析
- 错误测试

#### 白盒测试

称为**逻辑驱动测试**，允许我们对程序的内部进行逻辑结构检查，从中获取测试数据。其中，有一种方法，是根据程序的内部逻辑，穷举路径测试。但是这种不同逻辑路径的组合数量巨大，就和穷举输入测试法有些类似。并且即便穷举路径测试没有问题，也不能保证程序没有错误。

**总之**，尽管穷举输入测试要强于穷举路径测试，但两者都不是有效的方法，因为这两种方法都不可行。也许存在别的方法，将黑盒测试和白盒测试的要素结合起来，形成一个合理但并不完美的测试策略。这是接下来要学习的内容。

- 语句覆盖
- 判断覆盖
- 条件覆盖
- 判定/条件覆盖
- 多重条件覆盖

#### 软件测试的基本原则

1. 测试用例中一个必须部分是对预期输出或结果进行定义
2. 程序员避免测试自己编写的程序
3. 编写软件的组织不应当测试自己编写的软件
4. 应当彻底检查每个软件的执行后果
5. 测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况
6. 检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”
7. 应避免测试用例用后即弃，除非软件本身就是个一次性的软件
8. 计划测试工作是不应默许假定不会发现错误
9. 程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比
10. 软件测试是一项极富创造性，极具智力的挑战性的工作


#### 代码检查错误列表

| 数据引用错误                   | 运算错误                |
| ------------------------ | ------------------- |
| 1. 是否引用的变量未赋值或未初始化？      | 1. 是否存在非算数变量见得运算？   |
| 2. 下标的值是否在范围内？           | 2. 是否存在混合模式的运算？     |
| 3. 是否存在非整数下表？            | 3. 是否存在不同字长变量间的运算？  |
| 4. 是否存在虚调用？              | 4. 目标变量的大小是否小于赋值大小？ |
| 5. 当使用别名时属性是否正确？         | 5. 中间结果是否上溢或下溢？     |
| 6. 记录和结构的属性是否正确？         | 6. 是否存在被0除？         |
| 7. 是否计算位串的地址？是否传递位串参数？   | 7. 是否存在二进制的不精确度？    |
| 8. 基础的存储是否正确？            | 8. 变量的值是否超过了有意义的范围？ |
| 9. 跨过程的结构定义是否匹配？         | 9. 操作符的优先顺序是否被正确理解？ |
| 10. 索引或下标操作是否有“仅差一个”的错误？ | 10. 整数除法是否正确？       |
| 11. 继承需求是否得到满足？          |                     |

| 数据声明错误                  | 比较错误                      |
| ----------------------- | ------------------------- |
| 1. 是否所有的变量都已经声明？        | 1. 是否存在不同类型的变量名比较？        |
| 2. 默认的属性是否被正确理解？        | 2. 是否存在混合模式的比较运算？         |
| 3. 数组和字符串的初始化是否正确？      | 3. 比较运算符是否正确？             |
| 4. 变量是否赋予了正确的长度，类型和存储类？ | 4. 布尔表达式是否正确？             |
| 5. 初始化是否与存储类相一致？        | 5. 比较运算是否与布尔表达式相混合？       |
| 6. 是否有相似的变量名            | 6. 是否存在二进制小数的比较？          |
|                         | 7. 操作符的优先顺序是否被正确理解？       |
|                         | 8. 编辑器对布尔表达式的计算方式是否被正确理解？ |

| 控制流程错误                  | 输入/输出错误           |
| ----------------------- | ----------------- |
| 1. 是否超出了多条分支路径？         | 1. 文件的属性是否正确？     |
| 2. 是否每个循环都终止了？          | 2. OPEN语句是否正确？    |
| 3. 是否每个程序都终止了？          | 3. I/O语句是否符合格式规范？ |
| 4. 是否存在由于入口条件不满足而跳过循环体？ | 4. 缓冲大小与记录大小是否匹配？ |
| 5. 可能的循环越界是否正确？         | 5. 文件在使用前是否打开？    |
| 6. 是否存在“仅差一个”的迭代错误？     | 6. 文件在使用后是否关闭？    |
| 7. DO/END语句是否匹配？        | 7. 文件结束条件是否被正确处理？ |
| 8. 是否存在不能穷尽的判断？         | 8. 是否处理了I/O错误？    |
| 9. 输出信息中是否有文字或语法错误？     |                   |

| 接口错误                         | 其他检查                    |
| ---------------------------- | ----------------------- |
| 1. 形参的数量是否等于实参的数量？           | 1. 在交叉引用列表中是否存在未引用过的变量？ |
| 2. 形参的量纲是否与实参的量纲相匹配？         | 2. 属性列表是否与预期的相一致？       |
| 3. 传递给被调用模块的实参个数是否等于其形参个数？   | 3. 是否存在“警告” 或“提示”信息？    |
| 4. 传递给被调用模块的实参属性是否与其形参属性匹配？  | 4. 是否对输入的合法性进行检查？       |
| 5. 传递给被调用模块的实参量纲是否与其形参量纲相匹配？ | 5. 是否遗漏了某个功能？           |
| 6. 调用内部函数的实参的数量、属性，顺序是否正确？   |                         |
| 7. 是否引用了与当前入口无关的形参？          |                         |
| 8. 是否改变了某个原本仅为输入值的形参？        |                         |
| 9. 全局变量的定义在模块间是否一致？          |                         |
| 10. 常熟是否以实参形式传递过？            |                         |











---

